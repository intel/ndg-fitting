////////////////////////////////////////////////////////////////////////////////////////
// rtcore.h

@@{
embree2
=>
embree3
}@@

////////////////////////////////////////////////////////////////////////////////////////
// rtcore_config.h

@@{
RTCORE_VERSION_MAJOR
=>
RTC_VERSION_MAJOR
}@@

@@{
RTCORE_VERSION_MINOR
=>
RTC_VERSION_MINOR
}@@

@@{
RTCORE_VERSION_PATCH
=>
RTC_VERSION_PATCH
}@@

@@{
RTCORE_VERSION
=>
RTC_VERSION
}@@

@@{
RTCORE_VERSION_STRING
=>
RTC_VERSION_STRING
}@@

@@{
RTCORE_FORCEINLINE
=>
RTC_FORCEINLINE
}@@


////////////////////////////////////////////////////////////////////////////////////////
// rtcore_device.h

@@{
rtcNewDevice ()
=>
rtcNewDevice (NULL)
}@@

@@{
rtcDeleteDevice (EXPR e0)
=>
rtcReleaseDevice (e0)
}@@

@@{
rtcInit ()
=>
rtcInit (NULL)
}@@

@@{
rtcInit (EXPR e0);
=>
RTCDevice g_device = rtcInit (e0);
}@@

@@{
rtcExit ()
=>
rtcReleaseDevice (g_device)
}@@

@@{
RTC_SOFTWARE_CACHE_SIZE
=>
/*RTC_DEVICE_PROPERTY_SOFTWARE_CACHE_SIZE*/
}@@

@@{
RTC_CONFIG_INTERSECT1
=>
/*RTC_DEVICE_PROPERTY_NATIVE_RAY1_SUPPORTED (this is always supported)*/
}@@

@@{
RTC_CONFIG_INTERSECT4
=>
RTC_DEVICE_PROPERTY_NATIVE_RAY4_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECT8
=>
RTC_DEVICE_PROPERTY_NATIVE_RAY8_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECT16
=>
RTC_DEVICE_PROPERTY_NATIVE_RAY16_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECT_STREAM
=>
RTC_DEVICE_PROPERTY_RAY_STREAM_SUPPORTED
}@@

@@{
RTC_CONFIG_RAY_MASK
=>
RTC_DEVICE_PROPERTY_RAY_MASK_SUPPORTED
}@@

@@{
RTC_CONFIG_BACKFACE_CULLING
=>
RTC_DEVICE_PROPERTY_BACKFACE_CULLING_ENABLED
}@@

@@{
RTC_CONFIG_INTERSECTION_FILTER
=>
RTC_DEVICE_PROPERTY_FILTER_FUNCTION_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECTION_FILTER_RESTORE
=>
/*RTC_DEVICE_PROPERTY_INTERSECTION_FILTER_RESTORE*/
}@@

@@{
RTC_CONFIG_IGNORE_INVALID_RAYS
=>
RTC_DEVICE_PROPERTY_IGNORE_INVALID_RAYS_ENABLED
}@@

@@{
RTC_CONFIG_TASKING_SYSTEM
=>
RTC_DEVICE_PROPERTY_TASKING_SYSTEM
}@@

@@{
RTC_CONFIG_VERSION_MAJOR
=>
RTC_DEVICE_PROPERTY_VERSION_MAJOR
}@@

@@{
RTC_CONFIG_VERSION_MINOR
=>
RTC_DEVICE_PROPERTY_VERSION_MINOR
}@@

@@{
RTC_CONFIG_VERSION_PATCH
=>
RTC_DEVICE_PROPERTY_VERSION_PATCH
}@@

@@{
RTC_CONFIG_VERSION
=>
RTC_DEVICE_PROPERTY_VERSION
}@@

@@{
RTC_CONFIG_TRIANGLE_GEOMETRY
=>
RTC_DEVICE_PROPERTY_TRIANGLE_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_QUAD_GEOMETRY
=>
RTC_DEVICE_PROPERTY_QUAD_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_LINE_GEOMETRY
=>
RTC_DEVICE_PROPERTY_LINE_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_HAIR_GEOMETRY
=>
RTC_DEVICE_PROPERTY_HAIR_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_SUBDIV_GEOMETRY
=>
RTC_DEVICE_PROPERTY_SUBDIVISION_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_USER_GEOMETRY
=>
RTC_DEVICE_PROPERTY_USER_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_COMMIT_JOIN
=>
RTC_DEVICE_PROPERTY_JOIN_COMMIT_SUPPORTED
}@@

@@{
RTC_CONFIG_COMMIT_THREAD
=>
/*RTC_DEVICE_PROPERTY_COMMIT_THREAD_SUPPORTED*/
}@@

@@{
rtcSetParameter1i (EXPR parm,EXPR val)
=>
COMMENT rtcSetDeviceProperty (g_device,parm,val) // EMBREE_FIXME: not supported
}@@

@@{
rtcGetParameter1i (EXPR parm)
=>
rtcGetDeviceProperty (g_device,parm)
}@@

@@{
rtcDeviceSetParameter1i (EXPR device,EXPR parm,EXPR val)
=>
COMMENT rtcSetDeviceProperty (device,parm,val) // EMBREE_FIXME: not supported
}@@

@@{
rtcDeviceGetParameter1i (EXPR device,EXPR parm)
=>
rtcGetDeviceProperty (device,parm)
}@@

@@{
RTC_NO_ERROR
=>
RTC_ERROR_NONE
}@@

@@{
RTC_UNKNOWN_ERROR
=>
RTC_ERROR_UNKNOWN
}@@

@@{
RTC_INVALID_ARGUMENT
=>
RTC_ERROR_INVALID_ARGUMENT
}@@

@@{
RTC_INVALID_OPERATION
=>
RTC_ERROR_INVALID_OPERATION
}@@

@@{
RTC_OUT_OF_MEMORY
=>
RTC_ERROR_OUT_OF_MEMORY
}@@

@@{
RTC_UNSUPPORTED_CPU
=>
RTC_ERROR_UNSUPPORTED_CPU
}@@

@@{
RTC_CANCELLED
=>
RTC_ERROR_CANCELLED
}@@
  
@@{
rtcGetError ()
=>
rtcGetDeviceError (g_device)
}@@

@@{
rtcDeviceGetError (EXPR device)
=>
rtcGetDeviceError (device)
}@@

@@{
RTC_ERROR_FUNCTION
=>
RTCErrorFunction
}@@

@@{
RTCErrorFunc
=>
RTCErrorFunction
}@@

@@{
RTCErrorFunc2
=>
RTCErrorFunction
}@@

@@{
rtcSetErrorFunction(EXPR func)
=>
rtcSetDeviceErrorFunction(g_device,func,NULL)
}@@

@@{
rtcDeviceSetErrorFunction(EXPR device,EXPR func)
=>
rtcSetDeviceErrorFunction(device,func,NULL)
}@@

@@{
rtcDeviceSetErrorFunction2(EXPR device,EXPR func,EXPR userPtr)
=>
rtcSetDeviceErrorFunction(device,func,userPtr)
}@@

@@{cpp
void EXPR RTCErrorFunc (const RTCError ID error, const char* ID str)
{
=>
void RTCErrorFunc (uniform void* uniform userPtr, uniform RTCError ID error, const uniform char* uniform str)
{
}@@

@@{ispc
void EXPR RTCErrorFunc (const RTCError ID error, const char* ID str)
{
=>
void RTCErrorFunc (uniform void* uniform userPtr, uniform RTCError ID error, const uniform int8* uniform str)
{
}@@

@@{
RTC_MEMORY_MONITOR_FUNCTION
=>
RTCMemoryMonitorFunction
}@@

@@{
RTCMemoryMonitorFunc
=>
RTCMemoryMonitorFunction
}@@

@@{
RTCMemoryMonitorFunc2
=>
RTCMemoryMonitorFunction
}@@

@@{
rtcSetMemoryMonitorFunction(EXPR func)
=>
rtcSetDeviceMemoryMonitorFunction(g_device,func,NULL)
}@@

@@{
rtcDeviceSetMemoryMonitorFunction(EXPR device,EXPR func)
=>
rtcSetDeviceMemoryMonitorFunction(device,func,NULL)
}@@

@@{
rtcDeviceSetMemoryMonitorFunction2(EXPR device,EXPR func,EXPR userPtr)
=>
rtcSetDeviceMemoryMonitorFunction(device,func,userPtr)
}@@

@@{
void EXPR RTCMemoryMonitorFunc (const ssize_t ID bytes, const bool ID post)
{
=>
void RTCMemoryMonitorFunc (uniform void* uniform userPtr, uniform ssize_t bytes, uniform bool post)
{
}@@

@@{
rtcDebug();
=>
}@@

////////////////////////////////////////////////////////////////////////////////////////
// rtcore_scene.h

@@{
RTC_BUILD_QUALITY_NORMAL
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
RTC_SCENE_STATIC
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
RTC_SCENE_DYNAMIC
=>
RTC_SCENE_FLAG_DYNAMIC | RTC_BUILD_QUALITY_LOW
}@@

@@{
RTC_SCENE_COMPACT
=>
RTC_SCENE_FLAG_COMPACT
}@@

@@{
RTC_SCENE_COHERENT
=>
RTC_SCENE_FLAG_NONE
}@@

@@{
RTC_SCENE_INCOHERENT
=>
RTC_SCENE_FLAG_NONE
}@@

@@{
RTC_SCENE_HIGH_QUALITY
=>
RTC_BUILD_QUALITY_HIGH
}@@

@@{
RTC_SCENE_ROBUST
=>
RTC_SCENE_FLAG_ROBUST
}@@

@@{
RTCAlgorithmFlags ID id EXPR e0;
=>
@@{
ID id = EXPR e1;
=>
;
}@@
}@@

@@{
RTCAlgorithmFlags
=>
int
}@@

@@{
RTC_INTERSECT1
=>
0
}@@

@@{
RTC_INTERSECT4
=>
0
}@@

@@{
RTC_INTERSECT8
=>
0
}@@

@@{
RTC_INTERSECT16
=>
0
}@@

@@{
RTC_INTERPOLATE
=>
0
}@@

@@{
RTC_INTERSECT_STREAM
=>
0
}@@

@@{
RTCIntersectFlags
=>
RTCIntersectContextFlags
}@@

@@{
RTC_INTERSECT_COHERENT
=>
RTC_INTERSECT_CONTEXT_FLAG_COHERENT
}@@

@@{
RTC_INTERSECT_INCOHERENT
=>
RTC_INTERSECT_CONTEXT_FLAG_INCOHERENT
}@@

@@{
RTCIntersectContext ID context;
=>
uniform RTCIntersectContext context;
rtcInitIntersectContext(&context);
}@@

@@{
rtcNewScene(EXPR sflags,EXPR aflags)
=>
rtcDeviceNewScene(g_device,sflags,aflags)
}@@

@@{
rtcDeviceNewScene(EXPR device,EXPR sflags,EXPR aflags)
=>
rtcDeviceNewScene(device,sflags,aflags)
}@@

@@{
ID scene = rtcDeviceNewScene(EXPR device,EXPR sflags,EXPR aflags);
=>
scene = rtcNewScene(device);
COMMENT rtcSetSceneFlags(scene,sflags); // EMBREE_FIXME: set proper scene flags
COMMENT rtcSetSceneBuildQuality(scene,sflags); // EMBREE_FIXME: set proper build quality
}@@

@@{
return rtcDeviceNewScene(EXPR device,EXPR sflags,EXPR aflags);
=>
{
  RTCScene VAR scene = rtcNewScene(device);
  COMMENT rtcSetSceneFlags(scene,sflags); // EMBREE_FIXME: set proper scene flags
  COMMENT rtcSetSceneBuildQuality(scene,sflags); // EMBREE_FIXME: set proper build quality
  return scene;
}
}@@

@@{
RTC_PROGRESS_MONITOR_FUNCTION
=>
RTCProgressMonitorFunction
}@@

@@{
RTCProgressMonitorFunc
=>
RTCProgressMonitorFunction
}@@

@@{
rtcSetProgressMonitorFunction
=>
rtcSetSceneProgressMonitorFunction
}@@

@@{
rtcCommit(EXPR scene)
=>
rtcCommitScene(scene)
}@@

@@{
rtcCommitJoin(EXPR scene)
=>
rtcJoinCommitScene(scene)
}@@

@@{
rtcCommitThread(EXPR scene,EXPR threadID,EXPR numThreads)
=>
rtcJoinCommitScene(scene)
}@@

@@{
rtcGetBounds(EXPR scene,EXPR bounds)
=>
rtcGetSceneBounds(scene,&bounds)
}@@

@@{
rtcGetLinearBounds(EXPR scene,EXPR bounds)
=>
rtcGetSceneLinearBounds(scene,bounds)
}@@

@@{cpp
rtcIntersect(EXPR scene, EXPR query);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect1(scene,&context,&query);
  query.hit.Ng_x = -query.hit.Ng_x; // EMBREE_FIXME: only correct for triangles,quads, and subdivision surfaces
  query.hit.Ng_y = -query.hit.Ng_y;
  query.hit.Ng_z = -query.hit.Ng_z;
}
}@@

@@{ispc
rtcIntersect(EXPR scene, EXPR query);
=>
{
  uniform RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersectV(scene,&context,&query);
  query.hit.Ng_x = -query.hit.Ng_x;  // EMBREE_FIXME: only correct for triangles,quads, and subdivision surfaces
  query.hit.Ng_y = -query.hit.Ng_y;
  query.hit.Ng_z = -query.hit.Ng_z;
}
}@@

@@{cpp
rtcIntersect1Ex(EXPR scene,EXPR context,EXPR query);
=>
rtcIntersect1(scene,context,&query);
query.hit.Ng_x = -query.hit.Ng_x;  // EMBREE_FIXME: only correct for triangles,quads, and subdivision surfaces
query.hit.Ng_y = -query.hit.Ng_y;
query.hit.Ng_z = -query.hit.Ng_z;
}@@

@@{ispc
rtcIntersectEx(EXPR scene,EXPR context,EXPR query);
=>
rtcIntersectV(scene,context,&query);
query.hit.Ng_x = -query.hit.Ng_x;  // EMBREE_FIXME: only correct for triangles,quads, and subdivision surfaces
query.hit.Ng_y = -query.hit.Ng_y;
query.hit.Ng_z = -query.hit.Ng_z;
}@@

@@{
rtcIntersect4(EXPR valid,EXPR scene,EXPR query);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect4(valid,scene,&context,&query);
}
}@@

@@{
rtcIntersect4Ex(EXPR valid,EXPR scene,EXPR context,EXPR query);
=>
rtcIntersect4(valid,scene,context,&query);
}@@

@@{
rtcIntersect8(EXPR valid,EXPR scene,EXPR query);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect8(valid,scene,&context,&query);
}
}@@

@@{
rtcIntersect8Ex(EXPR valid,EXPR scene,EXPR context,EXPR query);
=>
rtcIntersect8(valid,scene,context,&query);
}@@

@@{
rtcIntersect16(EXPR valid,EXPR scene,EXPR query);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect16(valid,scene,&context,&query);
}
}@@

@@{
rtcIntersect16Ex(EXPR valid,EXPR scene,EXPR context,EXPR query);
=>
rtcIntersect16(valid,scene,context,&query);
}@@

@@{
rtcIntersectNp(EXPR scene,EXPR context,EXPR query,EXPR N);
=>
rtcIntersectNp(scene,context,&query,N);
}@@


@@{cpp
rtcOccluded(EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded1(scene,&context,&ray);
  COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}
}@@

@@{ispc
rtcOccluded(EXPR scene,EXPR ray);
=>
{
  uniform RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccludedV(scene,&context,&ray);
  COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}
}@@

@@{cpp
rtcOccluded1Ex(EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded1(scene,context,&ray);
COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}@@

@@{ispc
rtcOccluded1Ex(EXPR scene,EXPR context,EXPR ray);
=>
rtcOccludedV(scene,context,&ray);
COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}@@

@@{
rtcOccluded4(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded4(valid,scene,&context,&ray);
  COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}
}@@

@@{
rtcOccluded4Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded4(valid,scene,context,&ray);
COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}@@

@@{
rtcOccluded8(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded8(valid,scene,&context,&ray);
  COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}
}@@

@@{
rtcOccluded8Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded8(valid,scene,context,&ray);
COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}@@

@@{
rtcOccluded16(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded16(valid,scene,&context,&ray);
  COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}
}@@

@@{
rtcOccluded16Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded16(valid,scene,context,&ray);
COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}@@

@@{
rtcOccludedNp(EXPR scene,EXPR context,EXPR ray,EXPR N);
=>
rtcOccludedNp(scene,context,&ray,N);
COMMENT EMBREE_FIXME: ray is occluded when ray.tfar < 0.0f
}@@

@@{
rtcDeleteScene(EXPR scene)
=>
rtcReleaseScene(scene)
}@@

////////////////////////////////////////////////////////////////////////////////////////
// geometries

@@{
unsigned int ID geomID = REGEXPR(name,rtcNew.*)(
=>
uniform unsigned int geomID;
geomID = name(
}@@

@@{
int ID geomID = REGEXPR(name,rtcNew.*)(
=>
uniform int geomID;
geomID = name(
}@@

////////////////////////////////////////////////////////////////////////////////////////
// rtcore_geometry.h

@@{
RTC_MAX_TIME_STEPS
=>
RTC_MAX_TIME_STEP_COUNT
}@@

@@{
RTC_MAX_USER_VERTEX_BUFFERS
=>
65536
}@@

@@{
RTC_MAX_INDEX_BUFFERS
=>
65536
}@@

@@{
RTC_INDEX_BUFFER0
=>
RTC_INDEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_INDEX_BUFFER+EXPR t)
=>
RTC_INDEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_INDEX_BUFFER+EXPR t)
=>
RTC_INDEX_BUFFER_(t)
}@@

@@{
(RTCBufferType)RTC_INDEX_BUFFER
=>
RTC_INDEX_BUFFER
}@@

@@{
RTC_INDEX_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_INDEX,0)
}@@

@@{
RTC_INDEX_BUFFER1
=>
RTC_BUFFER(RTC_BUFFER_TYPE_INDEX,1)
}@@

@@{
RTC_INDEX_BUFFER_(EXPR slot)
=>
RTC_BUFFER(RTC_BUFFER_TYPE_INDEX,slot)
}@@


@@{
RTC_VERTEX_BUFFER0
=>
RTC_VERTEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_VERTEX_BUFFER+EXPR t)
=>
RTC_VERTEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_VERTEX_BUFFER+EXPR t)
=>
RTC_VERTEX_BUFFER_(t)
}@@

@@{
(RTCBufferType)RTC_VERTEX_BUFFER
=>
RTC_VERTEX_BUFFER
}@@

@@{
RTC_VERTEX_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX,0)
}@@

@@{
(RTCBufferType)RTC_VERTEX_BUFFER1
=>
RTC_VERTEX_BUFFER1
}@@

@@{
RTC_VERTEX_BUFFER1
=>
RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX,1)
}@@

@@{
RTC_VERTEX_BUFFER_(EXPR slot)
=>
RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX,slot)
}@@


@@{
RTC_USER_VERTEX_BUFFER0
=>
RTC_USER_VERTEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_USER_VERTEX_BUFFER+EXPR t)
=>
RTC_USER_VERTEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_USER_VERTEX_BUFFER+EXPR t)
=>
RTC_USER_VERTEX_BUFFER_(t)
}@@

@@{
RTC_USER_VERTEX_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,0)
}@@

@@{
RTC_USER_VERTEX_BUFFER1
=>
RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,1)
}@@

@@{
RTC_USER_VERTEX_BUFFER_(EXPR slot)
=>
RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,slot)
}@@


@@{
RTC_FACE_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_FACE,0)
}@@

@@{
RTC_LEVEL_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_LEVEL,0)
}@@

@@{
RTC_EDGE_CREASE_INDEX_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_EDGE_CREASE_INDEX,0)
}@@

@@{
RTC_EDGE_CREASE_WEIGHT_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT,0)
}@@

@@{
RTC_VERTEX_CREASE_INDEX_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX,0)
}@@

@@{
RTC_VERTEX_CREASE_WEIGHT_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT,0)
}@@

@@{
RTC_HOLE_BUFFER
=>
RTC_BUFFER(RTC_BUFFER_TYPE_HOLE,0)
}@@



@@{
RTCMatrixType
=>
uniform RTCFormat
}@@

@@{
RTC_MATRIX_ROW_MAJOR
=>
RTC_FORMAT_FLOAT3X4_ROW_MAJOR
}@@

@@{
RTC_MATRIX_COLUMN_MAJOR
=>
RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR
}@@

@@{
RTC_MATRIX_COLUMN_MAJOR_ALIGNED16
=>
RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR
}@@


@@{
RTCGeometryFlags
=>
uniform RTCBuildQuality
}@@

@@{
RTC_GEOMETRY_STATIC
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
RTC_GEOMETRY_DEFORMABLE
=>
RTC_BUILD_QUALITY_REFIT
}@@

@@{
RTC_GEOMETRY_DYNAMIC
=>
RTC_BUILD_QUALITY_LOW
}@@



@@{
RTCBoundaryMode
=>
uniform RTCSubdivisionMode
}@@

@@{
RTC_BOUNDARY_NONE
=>
RTC_SUBDIVISION_MODE_NO_BOUNDARY
}@@

@@{
RTC_BOUNDARY_SMOOTH
=>
RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY
}@@

@@{
RTC_BOUNDARY_EDGE_ONLY
=>
RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY
}@@

@@{
RTC_BOUNDARY_EDGE_AND_CORNER
=>
RTC_SUBDIVISION_MODE_PIN_CORNERS
}@@

@@{
RTC_SUBDIV_NO_BOUNDARY
=>
RTC_SUBDIVISION_MODE_NO_BOUNDARY
}@@

@@{
RTC_SUBDIV_SMOOTH_BOUNDARY
=>
RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY
}@@

@@{
RTC_SUBDIV_PIN_CORNERS
=>
RTC_SUBDIVISION_MODE_PIN_CORNERS
}@@

@@{
RTC_SUBDIV_PIN_BOUNDARY
=>
RTC_SUBDIVISION_MODE_PIN_BOUNDARY
}@@

@@{
RTC_SUBDIV_PIN_ALL
=>
RTC_SUBDIVISION_MODE_PIN_ALL
}@@





///////////////////////////////////////////////////////////////////////
// convert filter function callbacks

@@{
RTCFilterFunc
=>
RTCFilterFunctionN
}@@

@@{
RTCFilterFunc4
=>
RTCFilterFunctionN
}@@

@@{
RTCFilterFunc8
=>
RTCFilterFunctionN
}@@

@@{
RTCFilterFunc16
=>
RTCFilterFunctionN
}@@

@@{
RTCFilterFuncN
=>
RTCFilterFunctionN
}@@

@@{
void EXPR intersectionFilter(void* ID geometryUserPtr_in, RTCRay& ID ray_in)
{
=>
unmasked void intersectionFilter(const uniform RTCFilterFunctionNArguments* uniform args)
{
  uniform int* uniform valid = args->valid;
  varying int* uniform vvalid = (varying int* uniform ) valid;
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  COMMENT uniform RTCIntersectContext* uniform context = args->context;
  COMMENT varying RTCRay& ray_in = *(varying RTCRay* uniform ) args->ray;
  varying RTCHit* uniform hit = (varying RTCHit* uniform ) args->hit;
  #warning EMBREE_FIXME: use hit to access hit
  #warning EMBREE_FIXME: reject hit through *vvalid = 0 instead of ray_in.geomID = RTC_INVALID_GEOMETRY_ID;
  uniform unsigned int N = args->N;
  assert(N == __programCount);
  if (*vvalid != -1) return;
@@{
ray_in.
=>
hit->
}@@
}@@

@@{
void EXPR intersectionFilter(void* ID geometryUserPtr_in, RTCRay& ID ray_in);
=>
unmasked void intersectionFilter(const uniform RTCFilterFunctionNArguments* uniform args);
}@@

@@{
void EXPR intersectionFilter4(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay4& ID ray_in)
{
=>
void intersectionFilter4(const uniform RTCFilterFunctionNArguments* uniform args)
{
  const void* valid_in = args->valid;
  void* geometryUserPtr_in = args->geometryUserPtr;
  COMMENT RTCIntersectContext* context = args->context;
  COMMENT RTCRay4& ray_in = *(RTCRay4*) args->ray;
  RTCHit4* hit = (RTCHit4*) args->hit;
  #warning EMBREE_FIXME: use hit to access hit
  #warning EMBREE_FIXME: reject hit through *valid_in = 0 instead of ray_in.geomID = RTC_INVALID_GEOMETRY_ID;
  unsigned int N = args->N;
  assert(N == 4);
  if (none(valid)) return; // function may get called with zero mask
@@{
ray_in.
=>
hit->
}@@
}@@

@@{
void EXPR intersectionFilter4(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay4& ID ray_in);
=>
void intersectionFilter4(const uniform RTCFilterFunctionNArguments* uniform args);
}@@

@@{
void EXPR intersectionFilter8(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay8& ID ray_in)
{
=>
void intersectionFilter8(const uniform RTCFilterFunctionNArguments* uniform args)
{
  const void* valid_in = args->valid;
  void* geometryUserPtr_in = args->geometryUserPtr;
  COMMENT RTCIntersectContext* context = args->context;
  COMMENT RTCRay8& ray_in = *(RTCRay8*) args->ray;
  RTCHit8* hit = (RTCHit8*) args->hit;
  #warning EMBREE_FIXME: use hit to access hit
  #warning EMBREE_FIXME: reject hit through *valid_in = 0 instead of ray_in.geomID = RTC_INVALID_GEOMETRY_ID;
  unsigned int N = args->N;
  assert(N == 8);
  if (none(valid)) return; // function may get called with zero mask
@@{
ray_in.
=>
hit->
}@@
}@@

@@{
void EXPR intersectionFilter8(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay8& ID ray_in);
=>
void intersectionFilter8(const uniform RTCFilterFunctionNArguments* uniform args);
}@@

@@{
void EXPR intersectionFilter16(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay16& ID ray_in)
{
=>
void intersectionFilter16(const uniform RTCFilterFunctionNArguments* uniform args)
{
  const void* valid_in = args->valid;
  void* geometryUserPtr_in = args->geometryUserPtr;
  COMMENT RTCIntersectContext* context = args->context;
  COMMENT RTCRay16& ray_in = *(RTCRay16*) args->ray;
  RTCHit16* hit = (RTCHit16*) args->hit;
  #warning EMBREE_FIXME: use hit to access hit
  #warning EMBREE_FIXME: reject hit through *valid_in = 0 instead of ray_in.geomID = RTC_INVALID_GEOMETRY_ID;
  unsigned int N = args->N;
  assert(N == 16);
  if (none(valid)) return; // function may get called with zero mask
@@{
ray_in.
=>
hit->
}@@
}@@

@@{
void EXPR intersectionFilter16(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay16& ID ray_in);
=>
void intersectionFilter16(const uniform RTCFilterFunctionNArguments* uniform args);
}@@

@@{
void EXPR intersectionFilterN(int* ID valid_in, void* ID geometryUserPtr_in, const RTCIntersectContext* ID context_in, RTCRayN* ID ray_in, const RTCHitN* ID hit_in, const size_t ID N_in)
{
=>
void intersectionFilterN(const uniform RTCFilterFunctionNArguments* uniform args)
{
  int* uniform valid_in = args->valid;
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  RTCIntersectContext* uniform context_in = args->context;
  RTCRayN* uniform ray_in = args->ray;
  RTCHitN* uniform hit_in = args->hit;
  uniform unsigned int N_in = args->N;
  #warning EMBREE_FIXME: function may get called with zero valid mask
  #warning EMBREE_FIXME: reject hit through *valid_in = 0 instead of ray_in.geomID = RTC_INVALID_GEOMETRY_ID;
}@@

@@{
void EXPR intersectionFilterN(int* ID valid_in, void* ID geometryUserPtr_in, const RTCIntersectContext* ID context_in, RTCRayN* ID ray_in, const RTCHitN* ID hit_in, const size_t ID N_in);
=>
void intersectionFilterN(const uniform RTCFilterFunctionNArguments* uniform args);
}@@

///////////////////////////////////////////////////////////////////////
// convert displacement function callbacks

@@{
RTCDisplacementFunc
=>
RTCDisplacementFunctionN
}@@

@@{
RTCDisplacementFunc2
=>
RTCDisplacementFunctionN
}@@

@@{
void EXPR RTCDisplacementFunc(void* ID geometryUserPtr_in, unsigned int ID geomID_in, unsigned int ID primID_in,
const float* ID u_in, const float* ID v_in, const float* ID nx_in, const float* ID ny_in, const float* ID nz_in,
float* ID px_in, float* ID py_in, float* ID pz_in, size_t ID N_in)
{
=>
void RTCDisplacementFunc(const uniform RTCDisplacementFunctionNArguments* uniform args)
{
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  COMMENT uniform unsigned int geomID_in = args->geomID; // no longer available
  RTCGeometry geomID_in = args->geometry; 
  uniform unsigned int primID_in = args->primID;
  const float* uniform u_in = args->u;
  const float* uniform v_in = args->v;
  const float* uniform nx_in = args->Ng_x; // EMBREE_FIXME: negate Ng
  const float* uniform ny_in = args->Ng_y;
  const float* uniform nz_in = args->Ng_z;
  float* uniform px_in = args->P_x;
  float* uniform py_in = args->P_y;
  float* uniform pz_in = args->P_z;
  size_t uniform N_in = args->N;
}@@

@@{
void EXPR RTCDisplacementFunc2(void* ID geometryUserPtr_in, unsigned int ID geomID_in, unsigned int ID primID_in, unsigned int ID time_in,
const float* ID u_in, const float* ID v_in, const float* ID nx_in, const float* ID ny_in, const float* ID nz_in,
float* ID px_in, float* ID py_in, float* ID pz_in, size_t ID N_in)
{
=>
void RTCDisplacementFunc2(const uniform RTCDisplacementFunctionNArguments* uniform args)
{
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  COMMENT uniform unsigned int geomID_in = args->geomID; // no longer available
  RTCGeometry geomID_in = args->geometry; 
  uniform unsigned int primID_in = args->primID;
  uniform unsigned int time_in = args->timeStep;
  const float* uniform u_in = args->u;
  const float* uniform v_in = args->v;
  const float* uniform nx_in = args->Ng_x; // EMBREE_FIXME: negate Ng
  const float* uniform ny_in = args->Ng_y;
  const float* uniform nz_in = args->Ng_z;
  float* uniform px_in = args->P_x;
  float* uniform py_in = args->P_y;
  float* uniform pz_in = args->P_z;
  uniform size_t N_in = args->N;
}@@


////////////////////////////////////////////////////////////////////////////////////////
// instance

@@{
rtcNewInstance
=>
rtcNewInstance2
}@@

@@{
rtcNewInstance2
=>
rtcNewInstance3
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source)
=>
rtcNewInstance3(target,source,1)
}@@

@@{
LHS geomID = rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
geomID = rtcAttachGeometry(target,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
rtcAttachGeometry(target,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
rtcAttachGeometryById(target,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
RTCGeometry ID geom = rtcNewInstance(EXPR device,EXPR source,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewInstance(device,source,numTimeSteps);
rtcSetGeometryInstancedScene(geom,source);
rtcSetGeometryTimeStepCount(geom,numTimeSteps);
}@@


@@{
LHS geomID = rtcNewGeometryInstance(EXPR scene, EXPR geomID);
=>
geomID = rtcNewGeometryInstance( scene, geomID); // EMBREE_FIXME: no longer supported
}@@

@@{
LHS geomID = rtcNewGeometryGroup(EXPR scene, EXPR flags, EXPR geomIDs, EXPR N);
=>
geomID = rtcNewGeometryGroup(scene, flags, geomIDs, N); // EMBREE_FIXME: no longer supported
}@@

@@{
rtcSetTransform
=>
rtcSetTransform2
}@@

@@{
rtcSetTransform2(EXPR scene,EXPR geomID,EXPR layout,EXPR xfm)
=>
rtcSetTransform2(scene,geomID,layout,xfm,0)
}@@

@@{
rtcSetTransform2(EXPR scene,EXPR geomID,EXPR layout,EXPR xfm,EXPR timeStep)
=>
rtcSetGeometryTransform(rtcGetGeometry(scene,geomID),timeStep,layout,xfm)
}@@


////////////////////////////
// rtcNewTriangleMesh

@@{
rtcNewTriangleMesh
=>
rtcNewTriangleMesh2
}@@

@@{
rtcNewTriangleMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewTriangleMesh2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
LHS geomID = rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
RTCGeometry ID geom = rtcNewTriangleMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewTriangleMesh(device,flags,numPrimitives,numVertices,numTimeSteps);
rtcSetGeometryBuildQuality(geom,flags);
rtcSetGeometryTimeStepCount(geom,numTimeSteps);
}@@

////////////////////////////
// rtcNewQuadMesh

@@{
rtcNewQuadMesh
=>
rtcNewQuadMesh2
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewQuadMesh2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
LHS geomID = rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
RTCGeometry ID geom = rtcNewQuadMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewQuadMesh(device,flags,numPrimitives,numVertices,numTimeSteps);
rtcSetGeometryBuildQuality(geom,flags);
rtcSetGeometryTimeStepCount(geom,numTimeSteps);
}@@

////////////////////////////
// rtcNewSubdivisionMesh

@@{
rtcNewSubdivisionMesh
=>
rtcNewSubdivisionMesh2
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles)
=>
rtcNewSubdivisionMesh2(scene,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,1)
}@@

@@{
LHS geomID = rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
RTCGeometry ID geom = rtcNewSubdivisionMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewSubdivisionMesh(device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
rtcSetGeometryBuildQuality(geom,flags);
rtcSetGeometryTimeStepCount(geom,numTimeSteps);
}@@

////////////////////////////
// rtcNewCurveGeometry

@@{
rtcNewHairGeometry
=>
rtcNewBezierGeometry
}@@

@@{
rtcNewBezierHairGeometry
=>
rtcNewBezierHairGeometry2
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBezierHairGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@

@@{
rtcNewBSplineHairGeometry
=>
rtcNewBSplineHairGeometry2
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBSplineHairGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@




@@{
rtcNewCurveGeometry
=>
rtcNewBezierCurveGeometry
}@@

@@{
rtcNewBezierCurveGeometry
=>
rtcNewBezierCurveGeometry2
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBezierCurveGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@

@@{
rtcNewBSplineCurveGeometry
=>
rtcNewBSplineCurveGeometry2
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBSplineCurveGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@


@@{
rtcNewLineSegments
=>
rtcNewLineSegments2
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices)
=>
rtcNewLineSegments2(scene,flags,numSegments,numVertices,1)
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX (scene,RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE,flags,numSegments,numVertices,numTimeSteps)
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX (scene,RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE,flags,numSegments,numVertices,numTimeSteps,geomID)
}@@


@@{
LHS geomID = rtcNewCurveGeometryX (EXPR scene,EXPR type,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,type,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewCurveGeometryX (EXPR scene,EXPR type,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,type,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewCurveGeometryX (EXPR scene,EXPR type,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,type,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
RTCGeometry ID geom = rtcNewCurveGeometry (EXPR device,EXPR type,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewCurveGeometry (device,type,flags,numPrimitives,numVertices,numTimeSteps);
rtcSetGeometryBuildQuality(geom,flags);
rtcSetGeometryTimeStepCount(geom,numTimeSteps);
}@@


////////////////////////////////////////////////////////////////////////////////////////
// geometry modification functions

@@{
rtcSetTessellationRate(EXPR scene,EXPR geomID,EXPR rate)
=>
rtcSetGeometryTessellationRate(rtcGetGeometry(scene,geomID),rate)
}@@

@@{
rtcSetMask(EXPR scene,EXPR geomID,EXPR mask)
=>
rtcSetGeometryMask(rtcGetGeometry(scene,geomID),mask)
}@@

@@{
rtcSetBoundaryMode(EXPR scene,EXPR geomID,EXPR mode)
=>
rtcSetGeometrySubdivisionMode(rtcGetGeometry(scene,geomID),0,mode)
}@@

@@{
rtcSetSubdivisionMode(EXPR scene,EXPR geomID,EXPR topology,EXPR mode)
=>
rtcSetGeometrySubdivisionMode(rtcGetGeometry(scene,geomID),topology,mode)
}@@

@@{
rtcSetIndexBuffer(EXPR scene,EXPR geomID,EXPR buf0,EXPR buf1)
=>
rtcSetIndexBuffer(rtcGetGeometry(scene,geomID),buf0,buf1)
}@@

@@{
rtcSetIndexBuffer(EXPR geom, RTC_BUFFER(RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,EXPR vertexSlot) , RTC_BUFFER(RTC_BUFFER_TYPE_INDEX,EXPR indexSlot));
=>
rtcSetGeometryVertexAttributeTopology(geom, vertexSlot, indexSlot);
}@@

@@{
rtcSetIndexBuffer(EXPR geom, EXPR vertexBuffer, EXPR indexBuffer);
=>
rtcSetGeometryVertexAttributeTopology(geom, vertexBuffer, indexBuffer);
}@@

@@{
rtcMapBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcMapBuffer(rtcGetGeometry(scene,geomID),type)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER(EXPR type, EXPR slot))
=>
rtcMapBuffer(geom,type,slot,EMBREE_FIXME_COULD_NOT_INFER_FORMAT)
}@@

@@{
rtcMapBuffer(EXPR geom,EXPR type)
=>
rtcMapBuffer(geom,type,EMBREE_FIXME_COULD_NOT_INFER_SLOT,EMBREE_FIXME_COULD_NOT_INFER_FORMAT)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER_TYPE_FACE, EXPR slot, EXPR format)
=>
rtcMapBuffer(geom,RTC_BUFFER_TYPE_FACE,slot,RTC_FORMAT_UINT)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER_TYPE_LEVEL, EXPR slot, EXPR format)
=>
rtcMapBuffer(geom,RTC_BUFFER_TYPE_LEVEL,slot,RTC_FORMAT_FLOAT)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER_TYPE_EDGE_CREASE_INDEX, EXPR slot, EXPR format)
=>
rtcMapBuffer(geom,RTC_BUFFER_TYPE_EDGE_CREASE_INDEX,slot,RTC_FORMAT_UINT2)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT, EXPR slot, EXPR format)
=>
rtcMapBuffer(geom,RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT,slot,RTC_FORMAT_FLOAT)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX, EXPR slot, EXPR format)
=>
rtcMapBuffer(geom,RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX,slot,RTC_FORMAT_UINT)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT, EXPR slot, EXPR format)
=>
rtcMapBuffer(geom,RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT,slot,RTC_FORMAT_FLOAT)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER_TYPE_HOLE, EXPR slot, EXPR format)
=>
rtcMapBuffer(geom,RTC_BUFFER_TYPE_HOLE,slot,RTC_FORMAT_UINT)
}@@

@@{
rtcMapBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE, EXPR slot, EXPR format);
=>
(rtcSetGeometryVertexAttributeCount(geom,slot+1), // EMBREE_FIXME: verify if this is correct
 rtcMapBuffer(geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE, slot, format));
}@@

@@{
rtcUnmapBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcUnmapBuffer(rtcGetGeometry(scene,geomID),type)
}@@

@@{
rtcUnmapBuffer(EXPR geom, EXPR type);
=>
}@@

@@{
rtcSetBuffer(EXPR scene,EXPR geomID,EXPR type,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(rtcGetGeometry(scene,geomID),type,ptr,offset,stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
}@@

@@{
rtcSetBuffer2(EXPR scene,EXPR geomID,EXPR type,EXPR ptr,EXPR offset,EXPR stride,EXPR size)
=>
rtcSetBuffer(rtcGetGeometry(scene,geomID),type,ptr,offset,stride,size)
}@@

@@{
rtcSetBuffer(EXPR geom,RTC_BUFFER(EXPR type, EXPR slot),EXPR ptr,EXPR offset,EXPR stride,EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,type,slot,EMBREE_FIXME_COULD_NOT_INFER_FORMAT,ptr,offset,stride,size)
}@@

@@{
rtcSetBuffer(EXPR geom,EXPR type, EXPR ptr,EXPR offset,EXPR stride,EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,type,EMBREE_FIXME_COULD_NOT_INFER_SLOT,EMBREE_FIXME_COULD_NOT_INFER_FORMAT,ptr,offset,stride,size)
}@@


@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_FACE, EXPR slot, EXPR format, EXPR ptr, EXPR offset, EXPR stride, EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_FACE,slot,RTC_FORMAT_UINT,ptr,offset,stride,size)
}@@

@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_LEVEL, EXPR slot, EXPR format, EXPR ptr, EXPR offset, EXPR stride, EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_LEVEL,slot,RTC_FORMAT_FLOAT,ptr,offset,stride,size)
}@@

@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_EDGE_CREASE_INDEX, EXPR slot, EXPR format, EXPR ptr, EXPR offset, EXPR stride, EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_EDGE_CREASE_INDEX,slot,RTC_FORMAT_UINT2,ptr,offset,stride,size)
}@@

@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT, EXPR slot, EXPR format, EXPR ptr, EXPR offset, EXPR stride, EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT,slot,RTC_FORMAT_FLOAT,ptr,offset,stride,size)
}@@

@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX, EXPR slot, EXPR format, EXPR ptr, EXPR offset, EXPR stride, EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX,slot,RTC_FORMAT_UINT,ptr,offset,stride,size)
}@@

@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT, EXPR slot, EXPR format, EXPR ptr, EXPR offset, EXPR stride, EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT,slot,RTC_FORMAT_FLOAT,ptr,offset,stride,size)
}@@

@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_HOLE, EXPR slot, EXPR format, EXPR ptr, EXPR offset, EXPR stride, EXPR size)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_HOLE,slot,RTC_FORMAT_UINT,ptr,offset,stride,size)
}@@

@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE, EXPR slot, EXPR format, EXPR ptr, EXPR offset, EXPR stride, EXPR size);
=>
rtcSetGeometryVertexAttributeCount(geom,slot+1); // EMBREE_FIXME: verify if this is correct
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE, slot, format, ptr, offset, stride, size);
}@@



@@{
rtcEnable(EXPR scene,EXPR geomID)
=>
rtcEnableGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcUpdate(EXPR scene,EXPR geomID)
=>
rtcCommitGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcUpdateBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcUpdateGeometryBuffer(rtcGetGeometry(scene,geomID),type);
rtcCommitGeometry(rtcGetGeometry(scene,geomID)) /* EMBREE_FIXME: do commit once after all updates */
}@@

@@{
rtcUpdateGeometryBuffer(EXPR geom,RTC_BUFFER(EXPR bufty,EXPR slot))
=>
rtcUpdateGeometryBuffer(geom,bufty,slot)
}@@

@@{
rtcUpdateGeometryBuffer(EXPR geom,EXPR bufty)
=>
rtcUpdateGeometryBuffer(geom,bufty,EMBREE_FIXME_COULD_NOT_INFER_SLOT)
}@@

@@{
rtcDisable(EXPR scene,EXPR geomID)
=>
rtcDisableGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcSetDisplacementFunction(EXPR scene,EXPR geomID,EXPR func,EXPR bounds)
=>
rtcSetGeometryDisplacementFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetDisplacementFunction2(EXPR scene,EXPR geomID,EXPR func,EXPR bounds)
=>
rtcSetGeometryDisplacementFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction4(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction8(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction16(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunctionN(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction4(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction8(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction16(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunctionN(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@


@@{
rtcSetUserData(EXPR scene,EXPR geomID,EXPR ptr)
=>
rtcSetGeometryUserData(rtcGetGeometry(scene,geomID),ptr)
}@@

@@{
rtcGetUserData(EXPR scene,EXPR geomID)
=>
rtcGetGeometryUserData(rtcGetGeometry(scene,geomID))
}@@


@@{
rtcInterpolate(EXPR scene,EXPR geomID,EXPR primID,EXPR u,EXPR v,EXPR buffer,EXPR P,EXPR dPdu,EXPR dPdv,EXPR numFloats)
=>
rtcInterpolate1(rtcGetGeometry(scene,geomID),primID,u,v,buffer,P,dPdu,dPdv,numFloats)
}@@

@@{
rtcInterpolate1(EXPR geom,EXPR primID,EXPR u,EXPR v,RTC_BUFFER(EXPR bufty,EXPR slot),EXPR P,EXPR dPdu,EXPR dPdv,EXPR numFloats)
=>
rtcInterpolate1(geom,primID,u,v,bufty,slot,P,dPdu,dPdv,numFloats)
}@@

@@{
rtcInterpolate2(EXPR scene,EXPR geomID,EXPR primID,EXPR u,EXPR v,EXPR buffer,EXPR P,EXPR dPdu,EXPR dPdv,EXPR ddPdudu,EXPR ddPdvdv,EXPR ddPdudv,EXPR numFloats)
=>
rtcInterpolate2(rtcGetGeometry(scene,geomID),primID,u,v,buffer,P,dPdu,dPdv,ddPdudu,ddPdvdv,ddPdudv,numFloats)
}@@

@@{
rtcInterpolate2(EXPR geom,EXPR primID,EXPR u,EXPR v,RTC_BUFFER(EXPR bufty,EXPR slot),EXPR P,EXPR dPdu,EXPR dPdv,EXPR ddPdudu,EXPR ddPdvdv,EXPR ddPdudv,EXPR numFloats)
=>
rtcInterpolate2(rtcGetGeometry(scene,geomID),primID,u,v,bufty,slot,P,dPdu,dPdv,ddPdudu,ddPdvdv,ddPdudv,numFloats)
}@@


@@{
rtcInterpolateN(EXPR scene,EXPR geomID,EXPR valid_in,EXPR primID_in,EXPR u_in,EXPR v_in,EXPR numUVs_in,EXPR buffer_in,EXPR P_o,EXPR dPdu_o,EXPR dPdv_o,EXPR numFloats_in)
=>
{
  RTCInterpolateNArguments args;
  args.geometry = rtcGetGeometry(scene,geomID);
  args.valid = valid_in;
  args.primIDs = primID_in;
  args.u = u_in;
  args.v = v_in;
  args.N = numUVs_in;
  args.bufferType = buffer_in;
  args.bufferSlot = /* EMBREE_FIXME: put buffer slot here */;
  args.P = P_o;
  args.dPdu = dPdu_o;
  args.dPdv = dPdv_o;
  args.ddPdudu = NULL;
  args.ddPdvdv = NULL;
  args.ddPdudv = NULL;
  args.valueCount = numFloats_in;
  rtcInterpolateN(&args)
}
}@@

@@{
rtcInterpolateN2(EXPR scene,EXPR geomID,EXPR valid_in,EXPR primID_in,EXPR u_in,EXPR v_in,EXPR numUVs_in,EXPR buffer_in,EXPR P_o,EXPR dPdu_o,EXPR dPdv_o,EXPR ddPdudu_o,EXPR ddPdvdv_o,EXPR ddPdudv_o,EXPR numFloats_in)
=>
{
  RTCInterpolateNArguments args;
  args.geometry = rtcGetGeometry(scene,geomID);
  args.valid = valid_in;
  args.primIDs = primID_in;
  args.u = u_in;
  args.v = v_in;
  args.N = numUVs_in;
  args.bufferType = buffer_in;
  args.bufferSlot = /* EMBREE_FIXME: put buffer slot here */;
  args.P = P_o;
  args.dPdu = dPdu_o;
  args.dPdv = dPdv_o;
  args.ddPdudu = ddPdudu_o;
  args.ddPdvdv = ddPdvdv_o;
  args.ddPdudv = ddPdudv_o;
  args.valueCount = numFloats_in;
  rtcInterpolateN(&args)
}
}@@

@@{
rtcDeleteGeometry(EXPR scene,EXPR geomID)
=>
rtcReleaseGeometry(rtcGetGeometry(scene,geomID))
}@@

////////////////////////////////////////////////////////////////////////////////////////
// rtcore_geometry_user.h


@@{
RTCBoundsFunc
=>
RTCBoundsFunction
}@@

@@{
void EXPR RTCBoundsFunc(void* ID geometryUserPtr_in, size_t ID primID_in, RTCBounds& ID bounds_out)
{
=>
void RTCBoundsFunc(const uniform RTCBoundsFunctionArguments* uniform args)
{
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  uniform size_t primID_in = args->primID;
  COMMENT uniform unsigned int time = args->timeStep;
  uniform RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
RTCBoundsFunc2
=>
RTCBoundsFunction
}@@

@@{
void EXPR RTCBoundsFunc2(void* ID userPtr_in, void* ID geometryUserPtr_in, size_t ID primID_in, RTCBounds& ID bounds_out)
{
=>
void RTCBoundsFunc2(const uniform RTCBoundsFunctionArguments* uniform args)
{
  COMMENT void* uniform userPtr_in = args->userPtr; // no longer available
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  uniform size_t primID_in = args->primID;
  COMMENT uniform size_t time = args->timeStep;
  uniform RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
RTCBoundsFunc3
=>
RTCBoundsFunction
}@@

@@{
void EXPR RTCBoundsFunc3(void* ID userPtr_in, void* ID geometryUserPtr_in, size_t ID primID_in, size_t ID time_in, RTCBounds& ID bounds_out)
{
=>
void RTCBoundsFunc3(const uniform RTCBoundsFunctionArguments* uniform args)
{
  void* uniform userPtr_in = args->userPtr;
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  uniform size_t primID_in = args->primID;
  uniform size_t time_in = args->time;
  uniform RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
RTCIntersectFunc
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFunc
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFunc(void* ID geometryUserPtr_in, RTCRay& ID ray_in, size_t ID primID_in)
{
=>
unmasked void RTCIntersectFunc(const uniform RTCIntersectFunctionNArguments* uniform args) // EMBREE_FIXME: may also be RTCOccludedFunctionNArguments
{
  void* uniform valid_in = args->valid;
  varying int* uniform vvalid_in = (varying int* uniform ) valid_in;
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  COMMENT RTCIntersectContext* uniform context_in = args->context;
  varying RTCRayHit* uniform ray_ptr_in = (varying RTCRayHit* uniform ) args->rayhit;
  varying RTCRayHit& ray_in = *ray_ptr_in;
  uniform unsigned int N_in = args->N;
  uniform unsigned int primID_in = args->primID;
  assert(N_in == __programCount);
  if (*vvalid_in != -1) return;
  // EMBREE_FIXME: intersect func: on hit copy context_in->instID[0] to ray_in.hit.instID[0]
  // EMBREE_FIXME: occluded func: on hit set ray_in.tfar = -inf
}@@

@@{
RTCIntersectFunc4
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFunc4
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFunc4(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay4& ID ray_in, size_t ID primID_in)
{
=>
void RTCIntersectFunc4(const uniform RTCIntersectFunctionNArguments* uniform args) // EMBREE_FIXME: may also be RTCOccludedFunctionNArguments
{
  const void* valid_in = args->valid;
  void* geometryUserPtr_in = args->geometryUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRayHit4& ray_in = *(RTCRayHit4*) args->rayhit;
  unsigned int N_in = args->N;
  unsigned int primID_in = args->primID;
  assert(N_in == 4);
  // EMBREE_FIXME: intersect func: on hit copy context_in->instID[0] to ray_in.hit.instID[0]
  // EMBREE_FIXME: occluded func: on hit set ray_in.tfar = -inf
}@@

@@{
RTCIntersectFunc8
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFunc8
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFunc8(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay8& ID ray_in, size_t ID primID_in)
{
=>
void RTCIntersectFunc8(const uniform RTCIntersectFunctionNArguments* uniform args) // EMBREE_FIXME: may also be RTCOccludedFunctionNArguments
{
  const void* valid_in = args->valid;
  void* geometryUserPtr_in = args->geometryUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRayHit8& ray_in = *(RTCRayHit8*) args->rayhit;
  unsigned int N_in = args->N;
  unsigned int primID_in = args->primID;
  assert(N_in == 8);
  // EMBREE_FIXME: intersect func: on hit copy context_in->instID[0] to ray_in.hit.instID[0]
  // EMBREE_FIXME: occluded func: on hit set ray_in.tfar = -inf
}@@

@@{
RTCIntersectFunc16
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFunc16
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFunc16(const void* ID valid_in, void* ID geometryUserPtr_in, RTCRay16& ID ray_in, size_t ID primID_in)
{
=>
void RTCIntersectFunc16(const uniform RTCIntersectFunctionNArguments* uniform args) // EMBREE_FIXME: may also be RTCOccludedFunctionNArguments
{
  const void* valid_in = args->valid;
  void* geometryUserPtr_in = args->geometryUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRayHit16& ray_in = *(RTCRayHit16*) args->rayhit;
  unsigned int N_in = args->N;
  unsigned int primID_in = args->primID;
  assert(N_in == 16);
  // EMBREE_FIXME: intersect func: on hit copy context_in->instID[0] to ray_in.hit.instID[0]
  // EMBREE_FIXME: occluded func: on hit set ray_in.tfar = -inf
}@@

@@{
RTCIntersectFuncN
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFuncN
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFuncN(const int* ID valid_in, void* ID geometryUserPtr_in, const RTCIntersectContext* ID context_in, RTCRayN* ID ray_in, size_t ID N_in, size_t ID primID_in)
{
=>
void RTCIntersectFuncN(const uniform RTCIntersectFunctionNArguments* uniform args) // EMBREE_FIXME: may also be RTCOccludedFunctionNArguments
{
  const int* uniform valid_in = args->valid;
  void* uniform geometryUserPtr_in = args->geometryUserPtr;
  RTCIntersectContext* uniform context_in = args->context;
  RTCRayHitN* uniform ray_in = args->rayhit;
  uniform unsigned int N_in = args->N;
  uniform unsigned int primID_in = args->primID;
  // EMBREE_FIXME: intersect func: on hit copy context_in->instID[0] to ray_in.hit.instID[0]
  // EMBREE_FIXME: occluded func: on hit set ray_in.tfar = -inf
}@@

@@{
rtcNewUserGeometry
=>
rtcNewUserGeometry2
}@@

@@{
rtcNewUserGeometry2 (EXPR scene, EXPR numPrimitives)
=>
rtcNewUserGeometry2 (scene, numPrimitives, 1)
}@@

@@{
rtcNewUserGeometry2 (EXPR scene, EXPR numPrimitives, EXPR numTimeSteps)
=>
rtcNewUserGeometry3 (scene, RTC_BUILD_QUALITY_MEDIUM, numPrimitives, numTimeSteps)
}@@

@@{
rtcNewUserGeometry3 (EXPR scene, EXPR quality, EXPR numPrimitives)
=>
rtcNewUserGeometry3 (scene, quality, numPrimitives, 1)
}@@

@@{
rtcNewUserGeometry3
=>
rtcNewUserGeometry4
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives)
=>
rtcNewUserGeometry4 (scene, quality, numPrimitives, 1)
}@@

@@{
LHS geomID = rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
uniform RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
uniform RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps, EXPR geomID)
=>
uniform RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
RTCGeometry ID geom = rtcNewUserGeometry (EXPR device, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewUserGeometry (device, quality, numPrimitives, numTimeSteps);
rtcSetGeometryBuildQuality(geom,quality);
rtcSetGeometryUserPrimitiveCount(geom,numPrimitives);
rtcSetGeometryTimeStepCount(geom,numTimeSteps);
}@@


@@{
rtcSetBoundsFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,NULL)
}@@

@@{
rtcSetBoundsFunction2(EXPR scene,EXPR geomID,EXPR func,EXPR userPtr)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,userPtr)
}@@

@@{
rtcSetBoundsFunction3(EXPR scene,EXPR geomID,EXPR func,EXPR userPtr)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,userPtr)
}@@

@@{
rtcSetBoundsFunctionX(EXPR geom,EXPR func,EXPR userPtr)
=>
rtcSetGeometryBoundsFunction(geom,func,userPtr)
}@@

@@{
rtcSetIntersectFunction1Mp(EXPR scene,EXPR geomID,EXPR func);
=>
COMMENT rtcSetIntersectFunction1Mp(EXPR scene,EXPR geomID,EXPR func);
}@@

@@{
REGEXPR(name,rtcSetIntersectFunction.*)(
=>
rtcSetGeometryIntersectFunction(
}@@

@@{
rtcSetGeometryIntersectFunction (EXPR scene, EXPR geomID, EXPR func)
=>
rtcSetGeometryIntersectFunction (rtcGetGeometry(scene,geomID), func)
}@@

@@{
rtcSetOccludedFunction1Mp(EXPR scene,EXPR geomID,EXPR func);
=>
COMMENT rtcSetOccludedFunction1Mp(EXPR scene,EXPR geomID,EXPR func);
}@@

@@{
REGEXPR(name,rtcSetOccludedFunction.*)(
=>
rtcSetGeometryOccludedFunction(
}@@

@@{
rtcSetGeometryOccludedFunction (EXPR scene, EXPR geomID, EXPR func)
=>
rtcSetGeometryOccludedFunction (rtcGetGeometry(scene,geomID), func)
}@@


/////////////////////////////////
// optimize away rtcGetGeometry

@@{
LHS geomID = rtcAttachGeometry(EXPR scene,EXPR geom);
=>
geomID = rtcAttachGeometry(scene,geom);
@@{
rtcGetGeometry (EXPR scene,EXPR geomID)
=>
geom
}@@
}@@

@@{
rtcAttachGeometryById(EXPR scene,EXPR geom,EXPR geomID);
=>
rtcAttachGeometryById(scene,geom,geomID);
@@{
rtcGetGeometry (EXPR scene,EXPR geomID)
=>
geom
}@@
}@@

////////////////////////////////////////////////////////////////////////////////////////
// add rtcCommitGeometry before every return

@@{
RTCGeometry ID geom = REGEXPR(name,rtcNew.*)(
=>
uniform RTCGeometry geom = name(
@@{
return EXPR e0;
=>
rtcCommitGeometry(geom);
return e0;
}@@
}@@

/////////////////////////////////
// buffers

@@{
RTCGeometry ID geom = rtcNewTriangleMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewTriangleMesh(device,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,EXPR bufty,EXPR slot,EXPR format)
=>
rtcSetNewGeometryBuffer(geom,bufty,slot,format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_INDEX,EXPR slot,EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_INDEX,slot,RTC_FORMAT_UINT3,3*sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_INDEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_INDEX,slot,RTC_FORMAT_UINT3,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX,slot,RTC_FORMAT_FLOAT3,4*sizeof(uniform float),numVertices)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX,slot,RTC_FORMAT_FLOAT3,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,EXPR slot,EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,slot,format,ptr,offset,stride,numVertices)
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewQuadMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewQuadMesh(device,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,EXPR bufty,EXPR slot,EXPR format)
=>
rtcSetNewGeometryBuffer(geom,bufty,slot,format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_INDEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_INDEX,slot,RTC_FORMAT_UINT4,4*sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_INDEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_INDEX,slot,RTC_FORMAT_UINT4,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX,slot,RTC_FORMAT_FLOAT3,4*sizeof(uniform float),numVertices)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX,slot,RTC_FORMAT_FLOAT3,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,slot,format,ptr,offset,stride,numVertices)
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewSubdivisionMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewSubdivisionMesh(device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,EXPR bufty,EXPR slot,EXPR format)
=>
rtcSetNewGeometryBuffer(geom,bufty,slot,format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_FACE,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_FACE,slot,RTC_FORMAT_UINT,sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_FACE,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_FACE,slot,RTC_FORMAT_UINT,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_INDEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_INDEX,slot,RTC_FORMAT_UINT,sizeof(uniform int),numEdges)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_INDEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_INDEX,slot,RTC_FORMAT_UINT,ptr,offset,stride,numEdges)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX,slot,RTC_FORMAT_FLOAT3,4*sizeof(uniform float),numVertices)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX,slot,RTC_FORMAT_FLOAT3,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_LEVEL,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_LEVEL,slot,format,sizeof(uniform int),numEdges)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_LEVEL,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_LEVEL,slot,format,ptr,offset,stride,numEdges)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_EDGE_CREASE_INDEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_EDGE_CREASE_INDEX,slot,format,2*sizeof(uniform int),numEdgeCreases)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_EDGE_CREASE_INDEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_EDGE_CREASE_INDEX,slot,format,ptr,offset,stride,numEdgeCreases)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT,slot,format,sizeof(uniform float),numEdgeCreases)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT,slot,format,ptr,offset,stride,numEdgeCreases)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX,slot,format,sizeof(uniform int),numVertexCreases)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX,slot,format,ptr,offset,stride,numVertexCreases)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT,slot,format,sizeof(uniform float),numVertexCreases)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT,slot,format,ptr,offset,stride,numVertexCreases)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_HOLE,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_HOLE,slot,format,sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_HOLE,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_HOLE,slot,format,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,slot,format,ptr,offset,stride,numVertices) /* EMBREE_FIXME: verify size of this buffer! */
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewCurveGeometry (EXPR device,EXPR type,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewCurveGeometry (device,type,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,EXPR bufty,EXPR slot,EXPR format)
=>
rtcSetNewGeometryBuffer(geom,bufty,slot,format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_INDEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_INDEX,slot,RTC_FORMAT_UINT,sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_INDEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_INDEX,slot,RTC_FORMAT_UINT,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcSetNewGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX,EXPR slot, EXPR format,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetNewGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX,slot,RTC_FORMAT_FLOAT4,4*sizeof(uniform float),numVertices)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX,slot,RTC_FORMAT_FLOAT4,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetSharedGeometryBuffer(EXPR geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,EXPR slot, EXPR format,EXPR ptr,EXPR offset,EXPR stride,EMBREE_FIXME_COULD_NOT_INFER_SIZE)
=>
rtcSetSharedGeometryBuffer(geom,RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,slot,format,ptr,offset,stride,numVertices)
}@@
}@@


@@{
rtcMapBuffer(EXPR geom,EXPR type,EXPR slot, EXPR format)
=>
rtcGetGeometryBufferData(geom,type,slot) /* EMBREE_FIXME: check if this should be rtcSetNewGeometryBuffer */
}@@


////////////////////////////////////////////////
// drop extra arguments of geometry creation

@@{
rtcNewUserGeometry (EXPR device, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps);
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_USER); // EMBREE_FIXME: check if geometry gets properly committed
}@@

@@{
rtcNewTriangleMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_TRIANGLE); // EMBREE_FIXME: check if geometry gets properly committed
}@@

@@{
rtcNewQuadMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_QUAD); // EMBREE_FIXME: check if geometry gets properly committed
}@@

@@{
rtcNewSubdivisionMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_SUBDIVISION); // EMBREE_FIXME: check if geometry gets properly committed
}@@

@@{
rtcNewCurveGeometry (EXPR device,EXPR type,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
rtcNewGeometry (device,type); // EMBREE_FIXME: check if geometry gets properly committed
}@@

@@{
rtcNewInstance(EXPR device,EXPR source,EXPR numTimeSteps);
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_INSTANCE); // EMBREE_FIXME: check if geometry gets properly committed
}@@


////////////////////////////////////////////////
// rtcore_builder.h

@@{
RTCBuildSettings
=>
RTCBuildArguments
}@@

@@{
rtcDefaultBuildSettings
=>
rtcDefaultBuildArguments
}@@

@@{
RTCBuildArguments ID args
=>
uniform RTCBuildArguments args
@@{
ID args.size
=>
args.byteSize
}@@
@@{
ID args.quality
=>
args.buildQuality
}@@
@@{
ID args.flags
=>
args.buildFlags
}@@
@@{
ID args.travCost
=>
args.traversalCost
}@@
@@{
ID args.intCost
=>
args.intersectionCost
}@@
@@{
ID args.extraSpace
=>
args.primitiveArrayCapacity // EMBREE_FIXME: calculate capacity properly
}@@
}@@

@@{
rtcBuildBVH(EXPR bvh_i, EXPR settings, EXPR primitives_i, EXPR numPrimitives_i, EXPR createNode_i, EXPR setNodeChildren_i,
            EXPR setNodeBounds_i, EXPR createLeaf_i, EXPR splitPrimitive_i, EXPR buildProgress_i, EXPR userPtr_i);
=>
(settings.bvh = bvh_i,
settings.primitives = primitives_i,
settings.primitiveCount = numPrimitives_i,
settings.createNode = createNode_i,
settings.setNodeChildren = setNodeChildren_i,
settings.setNodeBounds = setNodeBounds_i,
settings.createLeaf = createLeaf_i,
settings.splitPrimitive = splitPrimitive_i,
settings.buildProgress = buildProgress_i,
settings.userPtr = userPtr_i,
rtcBuildBVH(&settings));
}@@

@@{
void* EXPR RTCCreateNodeFunc (RTCThreadLocalAllocator ID allocator, size_t ID numChildren, void* ID userPtr)
=>
void* RTCCreateNodeFunc (RTCThreadLocalAllocator allocator, unsigned int numChildren, void* userPtr)
}@@

@@{
void EXPR RTCSetNodeChildrenFunc (void* ID nodePtr, void** ID children, size_t ID numChildren, void* ID userPtr)
=>
void RTCSetNodeChildrenFunc (void* nodePtr, void** children, unsigned int numChildren, void* userPtr)
}@@

@@{
void EXPR RTCSetNodeBoundsFunc (void* ID nodePtr, const RTCBounds** ID bounds, size_t ID numChildren, void* ID userPtr)
=>
void RTCSetNodeBoundsFunc (void* nodePtr, const RTCBounds** bounds, unsigned int numChildren, void* userPtr)
}@@

//@@{
//void* EXPR RTCCreateLeafFunc (RTCThreadLocalAllocator ID allocator, const RTCBuildPrimitive* ID prims, size_t ID numPrims, void* ID userPtr)
//=>
//void* RTCCreateLeafFunc (RTCThreadLocalAllocator allocator, const RTCBuildPrimitive* prims, size_t numPrims, void* userPtr)
//}@@

@@{
void EXPR RTCSplitPrimitiveFunc (const RTCBuildPrimitive& ID prim, unsigned ID dim, float ID pos, RTCBounds& ID lbounds, RTCBounds& ID rbounds, void* ID userPtr)
{
=>
void RTCSplitPrimitiveFunc (const RTCBuildPrimitive* _prim, unsigned int dim, float pos, RTCBounds* _lbounds, RTCBounds* _rbounds, void* userPtr)
{
  const RTCBuildPrimitive& prim = *_prim;
  RTCBounds& lbounds = *_lbounds;
  RTCBounds& rbounds = *_rbounds;
}@@

@@{
void EXPR RTCBuildProgressFunc (size_t ID dn, void* ID userPtr)
{
=>
bool RTCBuildProgressFunc (void* uniform userPtr, uniform double _dn)
{
uniform size_t dn = _dn; // EMBREE_FIXME: multiply by number of primitives
return true; // EMBREE_FIXME: you have to return true from this function
}@@

@@{
rtcMakeStaticBVH(EXPR bvh)
=>
COMMENT rtcMakeStaticBVH(bvh)
// EMBREE_FIXME: set settings.flags = RTC_BUILD_FLAG_DYNAMIC instead
}@@

@@{
rtcDeleteBVH(EXPR bvh)
=>
rtcReleaseBVH(bvh)
}@@

////////////////////////////////////////////////
// special rules for tutorials

//@@{
//RTCRay
//=>
//varying Ray
//}@@
//
//@@{
//Ray ID myray
//=>
//varying Ray myray
//@@{cpp
//ID myray.tnear
//=>
//myray.tnear()
//}@@
//@@{cpp
//ID myray.tfar
//=>
//myray.tfar()
//}@@
//@@{
//&ID myray
//=>
//RTCRay_(myray)
//}@@
//@@{
//ID myray.Ng_x
//=>
//myray.Ng.x
//}@@
//@@{
//ID myray.Ng_y
//=>
//myray.Ng.y
//}@@
//@@{
//ID myray.Ng_z
//=>
//myray.Ng.z
//}@@
//}@@
//
//@@{
//Ray& ID myray =
//=>
//varying Ray& myray =
//@@{cpp
//ID myray.tnear
//=>
//myray.tnear()
//}@@
//@@{cpp
//ID myray.tfar
//=>
//myray.tfar()
//}@@
//@@{
//&ID myray
//=>
//RTCRay_(myray)
//}@@
//}@@
//
//@@{
//RTCIntersectContext* ID context_in = args->context;
//=>
//uniform IntersectContext* uniform context_in = (uniform IntersectContext* uniform ) args->context;
//}@@
//
//@@{
//RTCIntersectContext
//=>
//IntersectContext
//}@@
//
//@@{
//IntersectContext ID cont;
//=>
//uniform IntersectContext cont;
//@@{
//ID cont.flags
//=>
//cont.context.flags
//}@@
//@@{
//&ID cont
//=>
//&cont.context
//}@@
//}@@
//
//@@{
//LINEAR_BASIS
//=>
//RTC_GEOMETRY_TYPE_ROUND_OR_FLAT_LINEAR_CURVE
//}@@
//
//@@{
//BEZIER_BASIS
//=>
//RTC_GEOMETRY_TYPE_ROUND_OR_FLAT_BEZIER_CURVE
//}@@
//
//@@{
//BSPLINE_BASIS
//=>
//RTC_GEOMETRY_TYPE_ROUND_OR_FLAT_BSPLINE_CURVE
//}@@


////////////////////////////////////////////////
// rtcore_ray.h

@@{
RTCRay ID query;
=>
varying RTCRayHit query; // EMBREE_FIXME: use RTCRay for occlusion rays
query.ray.flags = 0;
@@{
ID query.orgx
=>
query.ray.org_x
}@@
@@{
ID query.orgy
=>
query.ray.org_y
}@@
@@{
ID query.orgz
=>
query.ray.org_z
}@@
@@{
ID query.tnear
=>
query.ray.tnear
}@@
@@{
ID query.dirx
=>
query.ray.dir_x
}@@
@@{
ID query.diry
=>
query.ray.dir_y
}@@
@@{
ID query.dirz
=>
query.ray.dir_z
}@@
@@{
ID query.tfar
=>
query.ray.tfar
}@@
@@{
ID query.time
=>
query.ray.time
}@@
@@{
ID query.mask
=>
query.ray.mask
}@@
@@{
ID query.Ngx
=>
query.hit.Ng_x
}@@
@@{
ID query.Ngy
=>
query.hit.Ng_y
}@@
@@{
ID query.Ngz
=>
query.hit.Ng_z
}@@
@@{
ID query.u
=>
query.hit.u
}@@
@@{
ID query.v
=>
query.hit.v
}@@
@@{
ID query.primID
=>
query.hit.primID
}@@
@@{
ID query.geomID
=>
query.hit.geomID
}@@
@@{
ID query.instID
=>
query.hit.instID[0]
}@@
}@@

@@{cpp
__programCount
=>
1
}@@

@@{
RTCRayN_instID(EXPR ray, EXPR N, EXPR i)
=>
RTCRayN_instID(ray,N,i,0)
}@@

@@{ispc
__programCount
=>
programCount
}@@


